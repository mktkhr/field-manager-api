// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: soil_types.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const getSoilType = `-- name: GetSoilType :one
SELECT
    id,
    large_code,
    middle_code,
    small_code,
    small_name,
    description,
    created_at,
    updated_at
FROM soil_types
WHERE id = $1
`

// 土壌タイプをIDで取得
func (q *Queries) GetSoilType(ctx context.Context, id uuid.UUID) (*SoilType, error) {
	row := q.db.QueryRow(ctx, getSoilType, id)
	var i SoilType
	err := row.Scan(
		&i.ID,
		&i.LargeCode,
		&i.MiddleCode,
		&i.SmallCode,
		&i.SmallName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSoilTypeBySmallCode = `-- name: GetSoilTypeBySmallCode :one
SELECT
    id,
    large_code,
    middle_code,
    small_code,
    small_name,
    description,
    created_at,
    updated_at
FROM soil_types
WHERE small_code = $1
`

// 土壌タイプを小分類コードで取得
func (q *Queries) GetSoilTypeBySmallCode(ctx context.Context, smallCode string) (*SoilType, error) {
	row := q.db.QueryRow(ctx, getSoilTypeBySmallCode, smallCode)
	var i SoilType
	err := row.Scan(
		&i.ID,
		&i.LargeCode,
		&i.MiddleCode,
		&i.SmallCode,
		&i.SmallName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listSoilTypes = `-- name: ListSoilTypes :many
SELECT
    id,
    large_code,
    middle_code,
    small_code,
    small_name,
    description,
    created_at,
    updated_at
FROM soil_types
ORDER BY large_code, middle_code, small_code
`

// 土壌タイプ一覧を取得
func (q *Queries) ListSoilTypes(ctx context.Context) ([]*SoilType, error) {
	rows, err := q.db.Query(ctx, listSoilTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SoilType{}
	for rows.Next() {
		var i SoilType
		if err := rows.Scan(
			&i.ID,
			&i.LargeCode,
			&i.MiddleCode,
			&i.SmallCode,
			&i.SmallName,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSoilType = `-- name: UpsertSoilType :one
INSERT INTO soil_types (
    large_code,
    middle_code,
    small_code,
    small_name
) VALUES (
    $1, $2, $3, $4
)
ON CONFLICT (small_code) DO UPDATE SET
    large_code = EXCLUDED.large_code,
    middle_code = EXCLUDED.middle_code,
    small_name = EXCLUDED.small_name,
    updated_at = NOW()
RETURNING id, large_code, middle_code, small_code, small_name, description, created_at, updated_at
`

type UpsertSoilTypeParams struct {
	LargeCode  string `json:"large_code"`
	MiddleCode string `json:"middle_code"`
	SmallCode  string `json:"small_code"`
	SmallName  string `json:"small_name"`
}

// 土壌タイプをUPSERT
func (q *Queries) UpsertSoilType(ctx context.Context, arg *UpsertSoilTypeParams) (*SoilType, error) {
	row := q.db.QueryRow(ctx, upsertSoilType,
		arg.LargeCode,
		arg.MiddleCode,
		arg.SmallCode,
		arg.SmallName,
	)
	var i SoilType
	err := row.Scan(
		&i.ID,
		&i.LargeCode,
		&i.MiddleCode,
		&i.SmallCode,
		&i.SmallName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
