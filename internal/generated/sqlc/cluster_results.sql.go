// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cluster_results.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const aggregateClustersByRes3 = `-- name: AggregateClustersByRes3 :many
SELECT
    h3_index_res3 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res3 IS NOT NULL
GROUP BY h3_index_res3
`

type AggregateClustersByRes3Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度3でfieldsを集計
func (q *Queries) AggregateClustersByRes3(ctx context.Context) ([]*AggregateClustersByRes3Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes3Row{}
	for rows.Next() {
		var i AggregateClustersByRes3Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes3ForCells = `-- name: AggregateClustersByRes3ForCells :many
SELECT
    h3_index_res3 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res3 = ANY($1::TEXT[])
GROUP BY h3_index_res3
`

type AggregateClustersByRes3ForCellsRow struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// 指定H3セル(res3)のみfieldsを集計(差分更新用)
func (q *Queries) AggregateClustersByRes3ForCells(ctx context.Context, h3Cells []string) ([]*AggregateClustersByRes3ForCellsRow, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes3ForCells, h3Cells)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes3ForCellsRow{}
	for rows.Next() {
		var i AggregateClustersByRes3ForCellsRow
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes5 = `-- name: AggregateClustersByRes5 :many
SELECT
    h3_index_res5 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res5 IS NOT NULL
GROUP BY h3_index_res5
`

type AggregateClustersByRes5Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度5でfieldsを集計
func (q *Queries) AggregateClustersByRes5(ctx context.Context) ([]*AggregateClustersByRes5Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes5)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes5Row{}
	for rows.Next() {
		var i AggregateClustersByRes5Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes5ForCells = `-- name: AggregateClustersByRes5ForCells :many
SELECT
    h3_index_res5 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res5 = ANY($1::TEXT[])
GROUP BY h3_index_res5
`

type AggregateClustersByRes5ForCellsRow struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// 指定H3セル(res5)のみfieldsを集計(差分更新用)
func (q *Queries) AggregateClustersByRes5ForCells(ctx context.Context, h3Cells []string) ([]*AggregateClustersByRes5ForCellsRow, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes5ForCells, h3Cells)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes5ForCellsRow{}
	for rows.Next() {
		var i AggregateClustersByRes5ForCellsRow
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes7 = `-- name: AggregateClustersByRes7 :many
SELECT
    h3_index_res7 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res7 IS NOT NULL
GROUP BY h3_index_res7
`

type AggregateClustersByRes7Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度7でfieldsを集計
func (q *Queries) AggregateClustersByRes7(ctx context.Context) ([]*AggregateClustersByRes7Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes7)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes7Row{}
	for rows.Next() {
		var i AggregateClustersByRes7Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes7ForCells = `-- name: AggregateClustersByRes7ForCells :many
SELECT
    h3_index_res7 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res7 = ANY($1::TEXT[])
GROUP BY h3_index_res7
`

type AggregateClustersByRes7ForCellsRow struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// 指定H3セル(res7)のみfieldsを集計(差分更新用)
func (q *Queries) AggregateClustersByRes7ForCells(ctx context.Context, h3Cells []string) ([]*AggregateClustersByRes7ForCellsRow, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes7ForCells, h3Cells)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes7ForCellsRow{}
	for rows.Next() {
		var i AggregateClustersByRes7ForCellsRow
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes9 = `-- name: AggregateClustersByRes9 :many
SELECT
    h3_index_res9 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res9 IS NOT NULL
GROUP BY h3_index_res9
`

type AggregateClustersByRes9Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度9でfieldsを集計
func (q *Queries) AggregateClustersByRes9(ctx context.Context) ([]*AggregateClustersByRes9Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes9)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes9Row{}
	for rows.Next() {
		var i AggregateClustersByRes9Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes9ForCells = `-- name: AggregateClustersByRes9ForCells :many
SELECT
    h3_index_res9 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res9 = ANY($1::TEXT[])
GROUP BY h3_index_res9
`

type AggregateClustersByRes9ForCellsRow struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// 指定H3セル(res9)のみfieldsを集計(差分更新用)
func (q *Queries) AggregateClustersByRes9ForCells(ctx context.Context, h3Cells []string) ([]*AggregateClustersByRes9ForCellsRow, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes9ForCells, h3Cells)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes9ForCellsRow{}
	for rows.Next() {
		var i AggregateClustersByRes9ForCellsRow
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAllClusterResults = `-- name: DeleteAllClusterResults :exec
DELETE FROM cluster_results
`

// 全クラスター結果を削除
func (q *Queries) DeleteAllClusterResults(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllClusterResults)
	return err
}

const deleteClusterResultsByH3Indexes = `-- name: DeleteClusterResultsByH3Indexes :exec
DELETE FROM cluster_results
WHERE resolution = $1 AND h3_index = ANY($2::TEXT[])
`

type DeleteClusterResultsByH3IndexesParams struct {
	Resolution int32    `json:"resolution"`
	H3Indexes  []string `json:"h3_indexes"`
}

// 指定H3インデックスのクラスター結果を削除(カウント0になったセル用)
func (q *Queries) DeleteClusterResultsByH3Indexes(ctx context.Context, arg *DeleteClusterResultsByH3IndexesParams) error {
	_, err := q.db.Exec(ctx, deleteClusterResultsByH3Indexes, arg.Resolution, arg.H3Indexes)
	return err
}

const deleteClusterResultsByResolution = `-- name: DeleteClusterResultsByResolution :exec
DELETE FROM cluster_results
WHERE resolution = $1
`

// 指定解像度のクラスター結果を全削除
func (q *Queries) DeleteClusterResultsByResolution(ctx context.Context, resolution int32) error {
	_, err := q.db.Exec(ctx, deleteClusterResultsByResolution, resolution)
	return err
}

const getClusterResults = `-- name: GetClusterResults :many
SELECT
    id,
    resolution,
    h3_index,
    field_count,
    center_lat,
    center_lng,
    calculated_at
FROM cluster_results
WHERE resolution = $1
ORDER BY h3_index
`

// 指定解像度のクラスター結果を取得
func (q *Queries) GetClusterResults(ctx context.Context, resolution int32) ([]*ClusterResult, error) {
	rows, err := q.db.Query(ctx, getClusterResults, resolution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ClusterResult{}
	for rows.Next() {
		var i ClusterResult
		if err := rows.Scan(
			&i.ID,
			&i.Resolution,
			&i.H3Index,
			&i.FieldCount,
			&i.CenterLat,
			&i.CenterLng,
			&i.CalculatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertClusterResult = `-- name: UpsertClusterResult :exec
INSERT INTO cluster_results (
    id,
    resolution,
    h3_index,
    field_count,
    center_lat,
    center_lng,
    calculated_at
)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
ON CONFLICT (resolution, h3_index)
DO UPDATE SET
    field_count = EXCLUDED.field_count,
    center_lat = EXCLUDED.center_lat,
    center_lng = EXCLUDED.center_lng,
    calculated_at = NOW()
`

type UpsertClusterResultParams struct {
	ID         uuid.UUID `json:"id"`
	Resolution int32     `json:"resolution"`
	H3Index    string    `json:"h3_index"`
	FieldCount int32     `json:"field_count"`
	CenterLat  float64   `json:"center_lat"`
	CenterLng  float64   `json:"center_lng"`
}

// クラスター結果をUPSERT
func (q *Queries) UpsertClusterResult(ctx context.Context, arg *UpsertClusterResultParams) error {
	_, err := q.db.Exec(ctx, upsertClusterResult,
		arg.ID,
		arg.Resolution,
		arg.H3Index,
		arg.FieldCount,
		arg.CenterLat,
		arg.CenterLng,
	)
	return err
}
