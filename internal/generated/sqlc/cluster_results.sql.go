// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cluster_results.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const aggregateClustersByRes3 = `-- name: AggregateClustersByRes3 :many
SELECT
    h3_index_res3 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res3 IS NOT NULL
GROUP BY h3_index_res3
`

type AggregateClustersByRes3Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度3でfieldsを集計
func (q *Queries) AggregateClustersByRes3(ctx context.Context) ([]*AggregateClustersByRes3Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes3Row{}
	for rows.Next() {
		var i AggregateClustersByRes3Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes5 = `-- name: AggregateClustersByRes5 :many
SELECT
    h3_index_res5 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res5 IS NOT NULL
GROUP BY h3_index_res5
`

type AggregateClustersByRes5Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度5でfieldsを集計
func (q *Queries) AggregateClustersByRes5(ctx context.Context) ([]*AggregateClustersByRes5Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes5)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes5Row{}
	for rows.Next() {
		var i AggregateClustersByRes5Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes7 = `-- name: AggregateClustersByRes7 :many
SELECT
    h3_index_res7 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res7 IS NOT NULL
GROUP BY h3_index_res7
`

type AggregateClustersByRes7Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度7でfieldsを集計
func (q *Queries) AggregateClustersByRes7(ctx context.Context) ([]*AggregateClustersByRes7Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes7)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes7Row{}
	for rows.Next() {
		var i AggregateClustersByRes7Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const aggregateClustersByRes9 = `-- name: AggregateClustersByRes9 :many
SELECT
    h3_index_res9 AS h3_index,
    COUNT(*)::INT AS field_count
FROM fields
WHERE h3_index_res9 IS NOT NULL
GROUP BY h3_index_res9
`

type AggregateClustersByRes9Row struct {
	H3Index    *string `json:"h3_index"`
	FieldCount int32   `json:"field_count"`
}

// H3解像度9でfieldsを集計
func (q *Queries) AggregateClustersByRes9(ctx context.Context) ([]*AggregateClustersByRes9Row, error) {
	rows, err := q.db.Query(ctx, aggregateClustersByRes9)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AggregateClustersByRes9Row{}
	for rows.Next() {
		var i AggregateClustersByRes9Row
		if err := rows.Scan(&i.H3Index, &i.FieldCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAllClusterResults = `-- name: DeleteAllClusterResults :exec
DELETE FROM cluster_results
`

// 全クラスター結果を削除
func (q *Queries) DeleteAllClusterResults(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllClusterResults)
	return err
}

const deleteClusterResultsByResolution = `-- name: DeleteClusterResultsByResolution :exec
DELETE FROM cluster_results
WHERE resolution = $1
`

// 指定解像度のクラスター結果を全削除
func (q *Queries) DeleteClusterResultsByResolution(ctx context.Context, resolution int32) error {
	_, err := q.db.Exec(ctx, deleteClusterResultsByResolution, resolution)
	return err
}

const getClusterResults = `-- name: GetClusterResults :many
SELECT
    id,
    resolution,
    h3_index,
    field_count,
    center_lat,
    center_lng,
    calculated_at
FROM cluster_results
WHERE resolution = $1
ORDER BY h3_index
`

// 指定解像度のクラスター結果を取得
func (q *Queries) GetClusterResults(ctx context.Context, resolution int32) ([]*ClusterResult, error) {
	rows, err := q.db.Query(ctx, getClusterResults, resolution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ClusterResult{}
	for rows.Next() {
		var i ClusterResult
		if err := rows.Scan(
			&i.ID,
			&i.Resolution,
			&i.H3Index,
			&i.FieldCount,
			&i.CenterLat,
			&i.CenterLng,
			&i.CalculatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertClusterResult = `-- name: UpsertClusterResult :exec
INSERT INTO cluster_results (
    id,
    resolution,
    h3_index,
    field_count,
    center_lat,
    center_lng,
    calculated_at
)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
ON CONFLICT (resolution, h3_index)
DO UPDATE SET
    field_count = EXCLUDED.field_count,
    center_lat = EXCLUDED.center_lat,
    center_lng = EXCLUDED.center_lng,
    calculated_at = NOW()
`

type UpsertClusterResultParams struct {
	ID         uuid.UUID `json:"id"`
	Resolution int32     `json:"resolution"`
	H3Index    string    `json:"h3_index"`
	FieldCount int32     `json:"field_count"`
	CenterLat  float64   `json:"center_lat"`
	CenterLng  float64   `json:"center_lng"`
}

// クラスター結果をUPSERT
func (q *Queries) UpsertClusterResult(ctx context.Context, arg *UpsertClusterResultParams) error {
	_, err := q.db.Exec(ctx, upsertClusterResult,
		arg.ID,
		arg.Resolution,
		arg.H3Index,
		arg.FieldCount,
		arg.CenterLat,
		arg.CenterLng,
	)
	return err
}
