// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: import_jobs.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const countImportJobs = `-- name: CountImportJobs :one
SELECT COUNT(*) FROM import_jobs
`

// インポートジョブの総数を取得
func (q *Queries) CountImportJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countImportJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImportJobsByStatus = `-- name: CountImportJobsByStatus :one
SELECT COUNT(*) FROM import_jobs WHERE status = $1
`

// ステータス別のインポートジョブ数を取得
func (q *Queries) CountImportJobsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countImportJobsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createImportJob = `-- name: CreateImportJob :one
INSERT INTO import_jobs (
    city_code,
    status
) VALUES (
    $1, 'pending'
) RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

// インポートジョブを作成
func (q *Queries) CreateImportJob(ctx context.Context, cityCode string) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, createImportJob, cityCode)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const getImportJob = `-- name: GetImportJob :one
SELECT
    id,
    city_code,
    status,
    total_records,
    processed_records,
    failed_records,
    last_processed_batch,
    s3_key,
    execution_arn,
    error_message,
    failed_record_ids,
    created_at,
    started_at,
    completed_at
FROM import_jobs
WHERE id = $1
`

// インポートジョブをIDで取得
func (q *Queries) GetImportJob(ctx context.Context, id uuid.UUID) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, getImportJob, id)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const listImportJobs = `-- name: ListImportJobs :many
SELECT
    id,
    city_code,
    status,
    total_records,
    processed_records,
    failed_records,
    last_processed_batch,
    s3_key,
    execution_arn,
    error_message,
    failed_record_ids,
    created_at,
    started_at,
    completed_at
FROM import_jobs
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type ListImportJobsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// インポートジョブ一覧を取得
func (q *Queries) ListImportJobs(ctx context.Context, arg *ListImportJobsParams) ([]*ImportJob, error) {
	rows, err := q.db.Query(ctx, listImportJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ImportJob{}
	for rows.Next() {
		var i ImportJob
		if err := rows.Scan(
			&i.ID,
			&i.CityCode,
			&i.Status,
			&i.TotalRecords,
			&i.ProcessedRecords,
			&i.FailedRecords,
			&i.LastProcessedBatch,
			&i.S3Key,
			&i.ExecutionArn,
			&i.ErrorMessage,
			&i.FailedRecordIds,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImportJobsByCityCode = `-- name: ListImportJobsByCityCode :many
SELECT
    id,
    city_code,
    status,
    total_records,
    processed_records,
    failed_records,
    last_processed_batch,
    s3_key,
    execution_arn,
    error_message,
    failed_record_ids,
    created_at,
    started_at,
    completed_at
FROM import_jobs
WHERE city_code = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type ListImportJobsByCityCodeParams struct {
	CityCode string `json:"city_code"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

// 市区町村コードでインポートジョブ一覧を取得
func (q *Queries) ListImportJobsByCityCode(ctx context.Context, arg *ListImportJobsByCityCodeParams) ([]*ImportJob, error) {
	rows, err := q.db.Query(ctx, listImportJobsByCityCode, arg.CityCode, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ImportJob{}
	for rows.Next() {
		var i ImportJob
		if err := rows.Scan(
			&i.ID,
			&i.CityCode,
			&i.Status,
			&i.TotalRecords,
			&i.ProcessedRecords,
			&i.FailedRecords,
			&i.LastProcessedBatch,
			&i.S3Key,
			&i.ExecutionArn,
			&i.ErrorMessage,
			&i.FailedRecordIds,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateImportJobError = `-- name: UpdateImportJobError :one
UPDATE import_jobs
SET
    status = 'failed',
    error_message = $2,
    failed_record_ids = $3,
    completed_at = NOW()
WHERE id = $1
RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

type UpdateImportJobErrorParams struct {
	ID              uuid.UUID       `json:"id"`
	ErrorMessage    *string         `json:"error_message"`
	FailedRecordIds json.RawMessage `json:"failed_record_ids"`
}

// インポートジョブのエラー情報を更新
func (q *Queries) UpdateImportJobError(ctx context.Context, arg *UpdateImportJobErrorParams) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, updateImportJobError, arg.ID, arg.ErrorMessage, arg.FailedRecordIds)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const updateImportJobExecutionArn = `-- name: UpdateImportJobExecutionArn :one
UPDATE import_jobs
SET
    execution_arn = $2
WHERE id = $1
RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

type UpdateImportJobExecutionArnParams struct {
	ID           uuid.UUID `json:"id"`
	ExecutionArn *string   `json:"execution_arn"`
}

// インポートジョブの実行ARNを更新
func (q *Queries) UpdateImportJobExecutionArn(ctx context.Context, arg *UpdateImportJobExecutionArnParams) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, updateImportJobExecutionArn, arg.ID, arg.ExecutionArn)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const updateImportJobProgress = `-- name: UpdateImportJobProgress :one
UPDATE import_jobs
SET
    processed_records = $2,
    failed_records = $3,
    last_processed_batch = $4
WHERE id = $1
RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

type UpdateImportJobProgressParams struct {
	ID                 uuid.UUID `json:"id"`
	ProcessedRecords   int32     `json:"processed_records"`
	FailedRecords      int32     `json:"failed_records"`
	LastProcessedBatch int32     `json:"last_processed_batch"`
}

// インポートジョブの進捗を更新
func (q *Queries) UpdateImportJobProgress(ctx context.Context, arg *UpdateImportJobProgressParams) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, updateImportJobProgress,
		arg.ID,
		arg.ProcessedRecords,
		arg.FailedRecords,
		arg.LastProcessedBatch,
	)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const updateImportJobS3Key = `-- name: UpdateImportJobS3Key :one
UPDATE import_jobs
SET
    s3_key = $2
WHERE id = $1
RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

type UpdateImportJobS3KeyParams struct {
	ID    uuid.UUID `json:"id"`
	S3Key *string   `json:"s3_key"`
}

// インポートジョブのS3キーを更新
func (q *Queries) UpdateImportJobS3Key(ctx context.Context, arg *UpdateImportJobS3KeyParams) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, updateImportJobS3Key, arg.ID, arg.S3Key)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const updateImportJobStatus = `-- name: UpdateImportJobStatus :one
UPDATE import_jobs
SET
    status = $2::VARCHAR,
    started_at = CASE WHEN $2::VARCHAR = 'processing' AND started_at IS NULL THEN NOW() ELSE started_at END,
    completed_at = CASE WHEN $2::VARCHAR IN ('completed', 'failed', 'partially_completed') THEN NOW() ELSE completed_at END
WHERE id = $1
RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

type UpdateImportJobStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

// インポートジョブのステータスを更新
func (q *Queries) UpdateImportJobStatus(ctx context.Context, arg *UpdateImportJobStatusParams) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, updateImportJobStatus, arg.ID, arg.Status)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const updateImportJobTotalRecords = `-- name: UpdateImportJobTotalRecords :one
UPDATE import_jobs
SET
    total_records = $2
WHERE id = $1
RETURNING id, city_code, status, total_records, processed_records, failed_records, last_processed_batch, s3_key, execution_arn, error_message, failed_record_ids, created_at, started_at, completed_at
`

type UpdateImportJobTotalRecordsParams struct {
	ID           uuid.UUID `json:"id"`
	TotalRecords *int32    `json:"total_records"`
}

// インポートジョブの総レコード数を更新
func (q *Queries) UpdateImportJobTotalRecords(ctx context.Context, arg *UpdateImportJobTotalRecordsParams) (*ImportJob, error) {
	row := q.db.QueryRow(ctx, updateImportJobTotalRecords, arg.ID, arg.TotalRecords)
	var i ImportJob
	err := row.Scan(
		&i.ID,
		&i.CityCode,
		&i.Status,
		&i.TotalRecords,
		&i.ProcessedRecords,
		&i.FailedRecords,
		&i.LastProcessedBatch,
		&i.S3Key,
		&i.ExecutionArn,
		&i.ErrorMessage,
		&i.FailedRecordIds,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return &i, err
}
